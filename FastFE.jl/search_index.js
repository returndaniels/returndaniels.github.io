var documenterSearchIndex = {"docs":
[{"location":"mde-discretization/#MDEDiscretization.jl-Discretização-de-Equações-Diferenciais-Modernas","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl - Discretização de Equações Diferenciais Modernas","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"O módulo MDEDiscretization.jl fornece ferramentas para a discretização de equações diferenciais ordinais (EDO) no contexto de elementos finitos. O objetivo principal deste módulo é facilitar a discretização do problema espacial e temporal, bem como fornecer funções auxiliares para resolver e analisar essas EDOs.","category":"page"},{"location":"mde-discretization/#Funções-Exportadas","page":"MDEDiscretization.jl","title":"Funções Exportadas","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Este módulo exporta as seguintes variáveis e funções:","category":"page"},{"location":"mde-discretization/#Variáveis-de-Parâmetros-da-EDO","page":"MDEDiscretization.jl","title":"Variáveis de Parâmetros da EDO","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"beta: Parâmetro beta da equação diferencial.\nalpha: Parâmetro alpha da equação diferencial.\ngamma: Parâmetro gamma da equação diferencial.","category":"page"},{"location":"mde-discretization/#Variáveis-de-Intervalos","page":"MDEDiscretization.jl","title":"Variáveis de Intervalos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"a: Limite inferior do intervalo espacial.\nb: Limite superior do intervalo espacial.\nT: Limite superior do intervalo temporal.\nnpg: Número de pontos de Gauss.\nne: Número de intervalos no espaço.\nm: Número de pontos internos no espaço.\nh: Passo no espaço.\ntau: Passo no tempo.\nN: Número de intervalos no tempo.","category":"page"},{"location":"mde-discretization/#Funções-de-Forma","page":"MDEDiscretization.jl","title":"Funções de Forma","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"φ1(ξ): Função de forma φ1 no elemento finito.\nφ2(ξ): Função de forma φ2 no elemento finito.\ndφ1(ξ): Derivada da função de forma φ1.\ndφ2(ξ): Derivada da função de forma φ2.","category":"page"},{"location":"mde-discretization/#Funções-de-Avaliação-nos-Pontos-de-Gauss","page":"MDEDiscretization.jl","title":"Funções de Avaliação nos Pontos de Gauss","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"φ1P: Avaliação de φ1 nos pontos de Gauss.\nφ2P: Avaliação de φ2 nos pontos de Gauss.\ndφ1P: Derivada de φ1 nos pontos de Gauss.\ndφ2P: Derivada de φ2 nos pontos de Gauss.\nWφ1P: Avaliação de φ1 multiplicada pelos pesos de Gauss.\nWφ2P: Avaliação de φ2 multiplicada pelos pesos de Gauss.","category":"page"},{"location":"mde-discretization/#Funções-Auxiliares","page":"MDEDiscretization.jl","title":"Funções Auxiliares","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"u(x, t): Função solução da EDO no ponto ( (x, t) ).\nu0(x): Função inicial ( u_0(x) ).\ndu0(x): Derivada da função inicial ( u_0(x) ).\ng(s): Função auxiliar ( g(s) ).\nf(x, t): Função ( f(x, t) ), dependente de ( x ) e ( t ).\nmonta_LG(ne): Função que monta a matriz de conectividade do elemento finito.\nmonta_EQ(ne): Função que monta o vetor de numeração das funções de forma.","category":"page"},{"location":"mde-discretization/#Exemplos-de-Uso","page":"MDEDiscretization.jl","title":"Exemplos de Uso","text":"","category":"section"},{"location":"mde-discretization/#1.-Solução-da-EDO","page":"MDEDiscretization.jl","title":"1. Solução da EDO","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para avaliar a solução ( u(x, t) ) da equação diferencial, você pode usar a função u(x, t):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x = 0.5   # Ponto espacial\nt = 0.2   # Ponto temporal\nsolucao = u(x, t)\nprintln(\"Solução u($x, $t) = $solucao\")","category":"page"},{"location":"mde-discretization/#2.-Função-Inicial-(-u_0(x)-)","page":"MDEDiscretization.jl","title":"2. Função Inicial ( u_0(x) )","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para avaliar a função inicial ( u_0(x) ), você pode usar a função u0(x):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x = 0.5   # Ponto espacial\nu0_value = u0(x)\nprintln(\"Valor de u0($x) = $u0_value\")","category":"page"},{"location":"mde-discretization/#3.-Derivada-da-Função-Inicial-(-u_0(x)-)","page":"MDEDiscretization.jl","title":"3. Derivada da Função Inicial ( u_0(x) )","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para calcular a derivada da função inicial ( u_0(x) ), use a função du0(x):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x = 0.5   # Ponto espacial\ndu0_value = du0(x)\nprintln(\"Derivada de u0($x) = $du0_value\")","category":"page"},{"location":"mde-discretization/#4.-Função-(-g(s)-)","page":"MDEDiscretization.jl","title":"4. Função ( g(s) )","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para calcular o valor da função auxiliar ( g(s) ), use a função g(s):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"s = 0.3   # Ponto no domínio de g\ng_value = g(s)\nprintln(\"Valor de g($s) = $g_value\")","category":"page"},{"location":"mde-discretization/#5.-Função-(-f(x,-t)-)","page":"MDEDiscretization.jl","title":"5. Função ( f(x, t) )","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para calcular a função ( f(x, t) ), use a função f(x, t):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x = 0.5   # Ponto espacial\nt = 0.2   # Ponto temporal\nf_value = f(x, t)\nprintln(\"Valor de f($x, $t) = $f_value\")","category":"page"},{"location":"mde-discretization/#6.-Montagem-da-Matriz-de-Conectividade","page":"MDEDiscretization.jl","title":"6. Montagem da Matriz de Conectividade","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para montar a matriz de conectividade do elemento finito, use a função monta_LG(ne):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"ne = 2^6   # Número de elementos finitos\nconectividade = monta_LG(ne)\nprintln(\"Matriz de Conectividade: \\n$conectividade\")","category":"page"},{"location":"mde-discretization/#7.-Montagem-do-Vetor-de-Numeração-das-Funções-de-Forma","page":"MDEDiscretization.jl","title":"7. Montagem do Vetor de Numeração das Funções de Forma","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Para montar o vetor de numeração das funções de forma, use a função monta_EQ(ne):","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"ne = 2^6   # Número de elementos finitos\nnumeracao = monta_EQ(ne)\nprintln(\"Vetor de Numeração: \\n$numeracao\")","category":"page"},{"location":"mde-discretization/#Descrição-das-Funções","page":"MDEDiscretization.jl","title":"Descrição das Funções","text":"","category":"section"},{"location":"mde-discretization/#u(x::Float64,-t::Float64)-Float64","page":"MDEDiscretization.jl","title":"u(x::Float64, t::Float64) -> Float64","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Avalia a solução ( u(x, t) ) da equação diferencial no ponto ( (x, t) ).","category":"page"},{"location":"mde-discretization/#Argumentos","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x::Float64: Ponto no domínio espacial de ( u ).\nt::Float64: Ponto no domínio temporal de ( u ).","category":"page"},{"location":"mde-discretization/#Retorno","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Valor de ( u(x, t) ) no ponto ( (x, t) ).","category":"page"},{"location":"mde-discretization/#u0(x::Float64)-Float64","page":"MDEDiscretization.jl","title":"u0(x::Float64) -> Float64","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Avalia a função inicial ( u_0(x) ) no ponto ( x ).","category":"page"},{"location":"mde-discretization/#Argumentos-2","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x::Float64: Ponto no domínio espacial de ( u_0 ).","category":"page"},{"location":"mde-discretization/#Retorno-2","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Valor de ( u_0(x) ) no ponto ( x ).","category":"page"},{"location":"mde-discretization/#du0(x::Float64)-Float64","page":"MDEDiscretization.jl","title":"du0(x::Float64) -> Float64","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Calcula a derivada de ( u_0(x) ) no ponto ( x ).","category":"page"},{"location":"mde-discretization/#Argumentos-3","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x::Float64: Ponto no domínio espacial de ( u_0 ).","category":"page"},{"location":"mde-discretization/#Retorno-3","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Derivada de ( u_0(x) ) no ponto ( x ).","category":"page"},{"location":"mde-discretization/#g(s::Float64)-Float64","page":"MDEDiscretization.jl","title":"g(s::Float64) -> Float64","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Avalia a função auxiliar ( g(s) ) no ponto ( s ).","category":"page"},{"location":"mde-discretization/#Argumentos-4","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"s::Float64: Ponto no domínio de ( g ).","category":"page"},{"location":"mde-discretization/#Retorno-4","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Valor de ( g(s) ) no ponto ( s ).","category":"page"},{"location":"mde-discretization/#f(x::Float64,-t::Float64)-Float64","page":"MDEDiscretization.jl","title":"f(x::Float64, t::Float64) -> Float64","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Avalia a função ( f(x, t) ) no ponto ( (x, t) ).","category":"page"},{"location":"mde-discretization/#Argumentos-5","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"x::Float64: Ponto no domínio espacial de ( f ).\nt::Float64: Ponto no domínio temporal de ( f ).","category":"page"},{"location":"mde-discretization/#Retorno-5","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Valor de ( f(x, t) ) no ponto ( (x, t) ).","category":"page"},{"location":"mde-discretization/#monta_LG(ne::Int64)-Matrix{Int64}","page":"MDEDiscretization.jl","title":"monta_LG(ne::Int64) -> Matrix{Int64}","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Monta a matriz de conectividade do elemento finito.","category":"page"},{"location":"mde-discretization/#Argumentos-6","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"ne::Int64: Número de elementos finitos.","category":"page"},{"location":"mde-discretization/#Retorno-6","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Matriz de conectividade.","category":"page"},{"location":"mde-discretization/#monta_EQ(ne::Int64)-Vector{Int64}","page":"MDEDiscretization.jl","title":"monta_EQ(ne::Int64) -> Vector{Int64}","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Monta o vetor de numeração das funções de forma.","category":"page"},{"location":"mde-discretization/#Argumentos-7","page":"MDEDiscretization.jl","title":"Argumentos","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"ne::Int64: Número de elementos finitos.","category":"page"},{"location":"mde-discretization/#Retorno-7","page":"MDEDiscretization.jl","title":"Retorno","text":"","category":"section"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Vetor com a numeração das funções de forma.","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"","category":"page"},{"location":"mde-discretization/","page":"MDEDiscretization.jl","title":"MDEDiscretization.jl","text":"Este módulo pode ser utilizado para discretizar e resolver equações diferenciais em problemas de elementos finitos. Ele oferece funções úteis para avaliação de soluções e montagem das matrizes de conectividade, sendo uma ferramenta valiosa para problemas de simulação numérica e análise de EDOs.","category":"page"},{"location":"using-documenter/#Como-utilizar-**Documenter.jl**-em-seu-projeto","page":"Usando o Documenter.jl","title":"Como utilizar Documenter.jl em seu projeto","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"O pacote Documenter.jl é uma ferramenta poderosa para gerar documentação de pacotes na linguagem Julia. Ele permite que você escreva documentação em markdown dentro do seu código e, em seguida, gere documentação estática ou interativa. Vou te guiar nos principais passos para usar o Documenter.jl para documentar seu pacote Julia.","category":"page"},{"location":"using-documenter/#Passos-principais:","page":"Usando o Documenter.jl","title":"Passos principais:","text":"","category":"section"},{"location":"using-documenter/#1.-**Adicionar-o-Documenter.jl-ao-seu-pacote**","page":"Usando o Documenter.jl","title":"1. Adicionar o Documenter.jl ao seu pacote","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Primeiro, você precisa adicionar o pacote Documenter.jl ao seu projeto:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"using Pkg\nPkg.add(\"Documenter\")","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Ou, se você estiver dentro do ambiente do seu pacote, você pode adicionar diretamente:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"using Pkg\nPkg.add(\"Documenter\")","category":"page"},{"location":"using-documenter/#2.-**Criar-o-diretório-de-documentação**","page":"Usando o Documenter.jl","title":"2. Criar o diretório de documentação","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Na estrutura do seu pacote, crie o diretório de documentação (docs) na raiz do pacote. A estrutura do diretório ficará assim:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"MyPackage/\n├── src/\n│   └── MyPackage.jl\n├── docs/\n│   ├── make.jl\n│   └── ...\n└── Project.toml","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"No diretório docs/, você precisará de um arquivo make.jl que o Documenter.jl usará para gerar a documentação.","category":"page"},{"location":"using-documenter/#3.-**Escrever-a-documentação-em-Markdown**","page":"Usando o Documenter.jl","title":"3. Escrever a documentação em Markdown","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"No diretório docs/, crie um arquivo index.md que conterá a documentação principal do seu pacote. Este arquivo usará markdown para organizar o conteúdo.","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"# MyPackage.jl Documentation\n\nBem-vindo à documentação do pacote **MyPackage.jl**.\n\n## Funções\n\n### `erro_vectorized`\n\n```julia\nerro_vectorized(u::Function, X::Matrix{Float64}, u_eval::Matrix{Float64}, ne::Int64, m::Int64, h::Float64, npg::Int64, C::Vector{Float64}, EQoLG::Matrix{Int64})::Float64\n```","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Calcula o erro para uma aproximação fornecida usando uma abordagem vetorizada.","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"...","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"\n#### 4. **Configurar o `make.jl`**\n\nCrie o arquivo `make.jl` no diretório `docs/` para configurar a geração da documentação.\n\n```julia\n# docs/make.jl\nusing Documenter\n\n# Inclui o pacote que você deseja documentar\nusing MyPackage\n\n# Configurações do Documenter\nmakedocs(\n    sitename = \"MyPackage.jl Documentation\",  # Nome do site/documentação\n    modules = [MyPackage],                    # Pacote a ser documentado\n    pages = [\n        \"Home\" => \"index.md\",                 # Página principal da documentação\n        \"API\" => \"api.md\"                     # Pode adicionar outras páginas, se necessário\n    ],\n    format = Documenter.HTML()                # Você pode escolher o formato HTML, Markdown, ou LaTeX\n)","category":"page"},{"location":"using-documenter/#5.-**Documentação-das-funções-e-tipos**","page":"Usando o Documenter.jl","title":"5. Documentação das funções e tipos","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Dentro do código do seu pacote, use os docstrings para documentar as funções e tipos. Por exemplo:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"\"\"\"\n    erro_vectorized(u::Function, X::Matrix{Float64}, u_eval::Matrix{Float64},\n                     ne::Int64, m::Int64, h::Float64, npg::Int64, C::Vector{Float64}, EQoLG::Matrix{Int64})::Float64\n\nCalcula o erro para uma aproximação fornecida usando uma abordagem vetorizada.\n\n# Parâmetros\n- `u`: Função que representa a solução exata.\n- `X`: Matriz de pontos de discretização.\n- `u_eval`: Matriz para armazenar os valores calculados da solução.\n- `ne`: Número de elementos.\n- `m`: Número de pontos de malha.\n- `h`: Tamanho do passo.\n- `npg`: Número de pontos por elemento.\n- `C`: Vetor de coeficientes.\n- `EQoLG`: Matriz de equações locais.\n\n# Retorno\nRetorna o erro calculado como um número de ponto flutuante.\n\"\"\"\nfunction erro_vectorized(u::Function, X::Matrix{Float64}, u_eval::Matrix{Float64},\n                         ne::Int64, m::Int64, h::Float64, npg::Int64, C::Vector{Float64}, EQoLG::Matrix{Int64})::Float64\n    ...\nend","category":"page"},{"location":"using-documenter/#6.-**Gerar-a-documentação**","page":"Usando o Documenter.jl","title":"6. Gerar a documentação","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Para gerar a documentação, abra o REPL da Julia e execute:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"using Documenter\ninclude(\"docs/make.jl\")","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Isso vai gerar a documentação na pasta docs/build/. Você pode agora abrir a documentação gerada no seu navegador.","category":"page"},{"location":"using-documenter/#7.-**Servir-a-documentação-localmente-(opcional)**","page":"Usando o Documenter.jl","title":"7. Servir a documentação localmente (opcional)","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Se você quiser servir a documentação localmente enquanto faz alterações, use:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"using Documenter\nDocumenter.serve(\"docs/build\")","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Isso vai abrir um servidor local e você poderá visualizar a documentação no seu navegador.","category":"page"},{"location":"using-documenter/#8.-**Publicar-a-documentação-(opcional)**","page":"Usando o Documenter.jl","title":"8. Publicar a documentação (opcional)","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Você pode publicar a documentação em sites como GitHub Pages. Para isso, você precisa configurar o repositório e garantir que a documentação seja gerada e publicada automaticamente ao fazer push para o repositório. O Documenter.jl possui suporte para configurar isso automaticamente com integração ao GitHub.","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"makedocs(\n    sitename = \"MyPackage.jl Documentation\",\n    modules = [MyPackage],\n    pages = [\"Home\" => \"index.md\"],\n    format = Documenter.HTML(),\n    repository = \"https://github.com/username/MyPackage.jl\",\n    deploy = Documenter.GitHubActions()  # Usando GitHub Actions para deploy automático\n)","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Essa configuração irá criar e publicar a documentação automaticamente no GitHub Pages.","category":"page"},{"location":"using-documenter/#Resumo","page":"Usando o Documenter.jl","title":"Resumo","text":"","category":"section"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Com o Documenter.jl, você pode gerar documentação do seu pacote Julia de forma simples e eficiente. O processo envolve:","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Adicionar o pacote Documenter.jl ao seu projeto.\nCriar um diretório docs/ contendo arquivos markdown e o script make.jl.\nEscrever a documentação no formato markdown.\nRodar o script make.jl para gerar a documentação HTML.\nPublicar a documentação, se desejado.","category":"page"},{"location":"using-documenter/","page":"Usando o Documenter.jl","title":"Usando o Documenter.jl","text":"Esses passos cobrem a criação e publicação básica da documentação do seu pacote Julia.","category":"page"},{"location":"vectorized-finite-elements/#Módulo-VectorizedFiniteElements","page":"VectorizedFiniteElements.jl","title":"Módulo VectorizedFiniteElements","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Este módulo contém funções otimizadas para o cálculo de matrizes de rigidez e vetores de forças externas utilizando o método dos elementos finitos (FEM), com o uso de vetorização para melhorar a eficiência computacional.","category":"page"},{"location":"vectorized-finite-elements/#Funções","page":"VectorizedFiniteElements.jl","title":"Funções","text":"","category":"section"},{"location":"vectorized-finite-elements/#K_vectorized","page":"VectorizedFiniteElements.jl","title":"K_vectorized","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Calcula a matriz global de rigidez ( K ) para um sistema de elementos finitos utilizando vetorização.","category":"page"},{"location":"vectorized-finite-elements/#Argumentos","page":"VectorizedFiniteElements.jl","title":"Argumentos","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"ne::Int64: Número de elementos finitos no domínio.\nm::Int64: Número de pontos no intervalo.\nh::Float64: Tamanho do passo no espaço.\nnpg::Int64: Número de pontos de Gauss utilizados na integração.\nalpha::Float64: Coeficiente (\\alpha) na equação diferencial.\nbeta::Float64: Coeficiente (\\beta) na equação diferencial.\ngamma::Float64: Coeficiente (\\gamma) na equação diferencial.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"vectorized-finite-elements/#Retorno","page":"VectorizedFiniteElements.jl","title":"Retorno","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Retorna uma matriz esparsa do tipo SparseMatrixCSC{Float64, Int64}, que representa a matriz de rigidez global ( K ).","category":"page"},{"location":"vectorized-finite-elements/#Exemplo-de-uso","page":"VectorizedFiniteElements.jl","title":"Exemplo de uso","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"using SparseArrays\nusing VectorizedFiniteElements\n\n# Definir parâmetros\nne = 10\nm = 5\nh = 0.1\nnpg = 3\nalpha = 1.0\nbeta = 2.0\ngamma = 3.0\nEQoLG = Matrix{Int64}(rand(10, 2))\n\n# Calcular a matriz de rigidez\nK = K_vectorized(ne, m, h, npg, alpha, beta, gamma, EQoLG)\nprintln(K)","category":"page"},{"location":"vectorized-finite-elements/#F_vectorized!","page":"VectorizedFiniteElements.jl","title":"F_vectorized!","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Calcula o vetor de forças externas ( F ) por meio de uma quadratura de Gauss, utilizando vetorização.","category":"page"},{"location":"vectorized-finite-elements/#Argumentos-2","page":"VectorizedFiniteElements.jl","title":"Argumentos","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"F_ext_vectorized::Vector{Float64}: Vetor de forças externas que será preenchido pela função.\nX::Matrix{Float64}: Matriz contendo as coordenadas dos pontos de Gauss no espaço.\nf_eval::Matrix{Float64}: Matriz contendo os valores da função ( f ) nos pontos de Gauss.\nvalues::Matrix{Float64}: Matriz de valores utilizados na avaliação da função ( f ) e no cálculo do vetor de forças.\nf::Function: Função a ser integrada numericamente sobre os elementos finitos.\nne::Int64: Número de elementos finitos no domínio.\nm::Int64: Número de pontos no intervalo.\nh::Float64: Tamanho do passo no espaço.\nnpg::Int64: Número de pontos de Gauss.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"vectorized-finite-elements/#Retorno-2","page":"VectorizedFiniteElements.jl","title":"Retorno","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Retorna o vetor F_ext_vectorized preenchido com as contribuições das forças externas, calculadas pela quadratura de Gauss.","category":"page"},{"location":"vectorized-finite-elements/#Exemplo-de-uso-2","page":"VectorizedFiniteElements.jl","title":"Exemplo de uso","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"using LinearAlgebra\nusing VectorizedFiniteElements\n\n# Definir parâmetros\nne = 10\nm = 5\nh = 0.1\nnpg = 3\nf(x) = sin(x)  # Função f a ser integrada\nX = rand(ne, m)\nf_eval = zeros(ne, m)\nvalues = zeros(ne, m)\nEQoLG = Matrix{Int64}(rand(ne, 2))\nF_ext = zeros(ne)\n\n# Calcular o vetor de forças externas\nF = F_vectorized!(F_ext, X, f_eval, values, f, ne, m, h, npg, EQoLG)\nprintln(F)","category":"page"},{"location":"vectorized-finite-elements/#G_vectorized!","page":"VectorizedFiniteElements.jl","title":"G_vectorized!","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Calcula o vetor de forças estendido ( G ) associado à função ( g ), utilizando vetorização.","category":"page"},{"location":"vectorized-finite-elements/#Argumentos-3","page":"VectorizedFiniteElements.jl","title":"Argumentos","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"G_ext_vectorized::Vector{Float64}: Vetor de forças estendidas que será preenchido pela função.\ng_eval::Matrix{Float64}: Matriz contendo os valores da função ( g ) nos pontos de Gauss.\nvalues::Matrix{Float64}: Matriz de valores utilizados na avaliação da função ( g ) e no cálculo do vetor de forças.\nC::Vector{Float64}: Vetor de coeficientes da solução aproximada ( C ).\nne::Int64: Número de elementos finitos no domínio.\nm::Int64: Número de pontos no intervalo.\nh::Float64: Tamanho do passo no espaço.\nnpg::Int64: Número de pontos de Gauss.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"vectorized-finite-elements/#Retorno-3","page":"VectorizedFiniteElements.jl","title":"Retorno","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Retorna o vetor G_ext_vectorized preenchido com as contribuições das forças associadas à função ( g ), calculadas pela quadratura de Gauss.","category":"page"},{"location":"vectorized-finite-elements/#Exemplo-de-uso-3","page":"VectorizedFiniteElements.jl","title":"Exemplo de uso","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"using LinearAlgebra\nusing VectorizedFiniteElements\n\n# Definir parâmetros\nne = 10\nm = 5\nh = 0.1\nnpg = 3\ng(x) = cos(x)  # Função g a ser integrada\nC = rand(ne)\ng_eval = zeros(ne, m)\nvalues = zeros(ne, m)\nEQoLG = Matrix{Int64}(rand(ne, 2))\nG_ext = zeros(ne)\n\n# Calcular o vetor de forças estendidas\nG = G_vectorized!(G_ext, g_eval, values, C, ne, m, h, npg, EQoLG)\nprintln(G)","category":"page"},{"location":"vectorized-finite-elements/#Exportação-das-funções","page":"VectorizedFiniteElements.jl","title":"Exportação das funções","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"As funções K_vectorized, F_vectorized! e G_vectorized! são exportadas pelo módulo para que possam ser usadas externamente:","category":"page"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"export K_vectorized, F_vectorized!, G_vectorized!","category":"page"},{"location":"vectorized-finite-elements/#Requisitos","page":"VectorizedFiniteElements.jl","title":"Requisitos","text":"","category":"section"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"Este módulo depende de:","category":"page"},{"location":"vectorized-finite-elements/","page":"VectorizedFiniteElements.jl","title":"VectorizedFiniteElements.jl","text":"SparseArrays para o cálculo de matrizes esparsas.\nLinearAlgebra para operações matriciais.","category":"page"},{"location":"serial-finite-elements/#Documentação-do-módulo-SerialFiniteElements","page":"SerialFiniteElements.jl","title":"Documentação do módulo SerialFiniteElements","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Este módulo fornece funções para resolver problemas de elementos finitos utilizando métodos sequenciais. As funções implementadas incluem o cálculo da matriz de rigidez global, o vetor de forças externas, e a solução para o erro integral L2, entre outras operações de discretização e integração numérica.","category":"page"},{"location":"serial-finite-elements/#Funções","page":"SerialFiniteElements.jl","title":"Funções","text":"","category":"section"},{"location":"serial-finite-elements/#K_serial","page":"SerialFiniteElements.jl","title":"K_serial","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Calcula a matriz de rigidez global K a partir das matrizes locais, utilizando pontos de Gauss e pesos para a integração numérica. Esta função é implementada de forma sequencial.","category":"page"},{"location":"serial-finite-elements/#Argumentos:","page":"SerialFiniteElements.jl","title":"Argumentos:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"ne::Int64: Número de elementos finitos no domínio de u.\nm::Int64: Número de pontos no intervalo (a, b).\nh::Float64: Tamanho do passo no espaço.\nnpg::Int64: Número de pontos de Gauss.\nalpha::Float64: Coeficiente alpha na equação diferencial.\nbeta::Float64: Coeficiente beta na equação diferencial.\ngamma::Float64: Coeficiente gamma na equação diferencial.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"serial-finite-elements/#Retorno:","page":"SerialFiniteElements.jl","title":"Retorno:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Retorna uma matriz esparsa de tipo SparseMatrixCSC{Float64, Int64} com a matriz de rigidez global.","category":"page"},{"location":"serial-finite-elements/#Exemplo-de-Uso:","page":"SerialFiniteElements.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"# Parâmetros\nne = 10\nm = 100\nh = 0.1\nnpg = 3\nalpha = 1.0\nbeta = 0.5\ngamma = 0.3\nEQoLG = rand(10, 2)  # Exemplo de mapeamento local-global\n\n# Chamada da função\nK = K_serial(ne, m, h, npg, alpha, beta, gamma, EQoLG)\nprintln(K)","category":"page"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"","category":"page"},{"location":"serial-finite-elements/#F_serial!","page":"SerialFiniteElements.jl","title":"F_serial!","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Calcula a quadratura gaussiana do vetor de forças externas F_ext associada à equação diferencial.","category":"page"},{"location":"serial-finite-elements/#Argumentos:-2","page":"SerialFiniteElements.jl","title":"Argumentos:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"F_ext_serial::Vector{Float64}: Vetor de forças externas estendido a ser preenchido.\nx::Vector{Float64}: Vetor de pontos de Gauss no domínio de f.\nf::Function: Função que representa a equação diferencial.\nne::Int64: Número de elementos finitos no intervalo.\nm::Int64: Número de pontos no intervalo (a, b).\nh::Float64: Tamanho do passo no espaço.\nnpg::Int64: Número de pontos de Gauss.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"serial-finite-elements/#Retorno:-2","page":"SerialFiniteElements.jl","title":"Retorno:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Retorna o vetor F_ext_serial com os valores calculados pela quadratura gaussiana.","category":"page"},{"location":"serial-finite-elements/#Exemplo-de-Uso:-2","page":"SerialFiniteElements.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"# Parâmetros\nF_ext_serial = zeros(Float64, ne)\nx = linspace(0, 1, m)\nf(x) = x^2  # Exemplo de função f(x)\n\n# Chamada da função\nF_ext_serial = F_serial!(F_ext_serial, x, f, ne, m, h, npg, EQoLG)\nprintln(F_ext_serial)","category":"page"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"","category":"page"},{"location":"serial-finite-elements/#G_serial!","page":"SerialFiniteElements.jl","title":"G_serial!","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Calcula a quadratura gaussiana associada ao vetor G_ext considerando os coeficientes C da solução aproximada.","category":"page"},{"location":"serial-finite-elements/#Argumentos:-3","page":"SerialFiniteElements.jl","title":"Argumentos:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"G_ext_serial::Vector{Float64}: Vetor de forças estendidas a ser preenchido.\nC::Vector{Float64}: Vetor de coeficientes da solução aproximada u.\nne::Int64: Número de elementos finitos no intervalo.\nm::Int64: Número de pontos no intervalo (a, b).\nh::Float64: Passo no domínio espacial.\nnpg::Int64: Número de pontos de Gauss.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"serial-finite-elements/#Retorno:-3","page":"SerialFiniteElements.jl","title":"Retorno:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Retorna o vetor G_ext_serial preenchido com os valores calculados pela quadratura gaussiana.","category":"page"},{"location":"serial-finite-elements/#Exemplo-de-Uso:-3","page":"SerialFiniteElements.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"# Parâmetros\nG_ext_serial = zeros(Float64, ne)\nC = rand(Float64, ne)  # Coeficientes da solução\n\n# Chamada da função\nG_ext_serial = G_serial!(G_ext_serial, C, ne, m, h, npg, EQoLG)\nprintln(G_ext_serial)","category":"page"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"","category":"page"},{"location":"serial-finite-elements/#erro_serial","page":"SerialFiniteElements.jl","title":"erro_serial","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Calcula o erro integral L2 entre a solução exata u e a solução aproximada representada pelos coeficientes C.","category":"page"},{"location":"serial-finite-elements/#Argumentos:-4","page":"SerialFiniteElements.jl","title":"Argumentos:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"u::Function: Função solução exata.\nx::Vector{Float64}: Vetor de pontos de Gauss no domínio de f.\nne::Int64: Número de elementos finitos no domínio de u.\nm::Int64: Número de pontos no intervalo (a, b).\nh::Float64: Tamanho do passo no espaço.\nnpg::Int64: Número de pontos de Gauss.\nC::Vector{Float64}: Vetor com os coeficientes da solução aproximada.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"serial-finite-elements/#Retorno:-4","page":"SerialFiniteElements.jl","title":"Retorno:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Retorna o erro L2 entre a solução exata u e a solução aproximada.","category":"page"},{"location":"serial-finite-elements/#Exemplo-de-Uso:-4","page":"SerialFiniteElements.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"# Função solução exata\nu(x) = sin(x)\n\n# Chamada da função\nerro = erro_serial(u, x, ne, m, h, npg, C, EQoLG)\nprintln(\"Erro L2: \", erro)","category":"page"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"","category":"page"},{"location":"serial-finite-elements/#C0_options","page":"SerialFiniteElements.jl","title":"C0_options","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Calcula o vetor C0 de coeficientes iniciais, dado o tipo de inicialização especificado.","category":"page"},{"location":"serial-finite-elements/#Argumentos:-5","page":"SerialFiniteElements.jl","title":"Argumentos:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"op::Int64: Opção de inicialização do vetor C0.\n1: Interpolação da condição inicial u0.\n2: Projeção L2 de u0.\n3: Projeção H de u0.\n4: Operador k(u, v) como projeção de u0.\nu0::Function: Função que representa a condição inicial no tempo.\na::Float64: Limite inferior do domínio de u.\nne::Int64: Número de elementos finitos no domínio espacial.\nm::Int64: Número de pontos no intervalo (a, b).\nh::Float64: Tamanho do passo no espaço.\nalpha::Float64: Coeficiente alpha na equação diferencial.\nbeta::Float64: Coeficiente beta na equação diferencial.\ngamma::Float64: Coeficiente gamma na equação diferencial.\nnpg::Int64: Número de pontos de Gauss.\nEQoLG::Matrix{Int64}: Matriz de mapeamento de elementos locais para globais.","category":"page"},{"location":"serial-finite-elements/#Retorno:-5","page":"SerialFiniteElements.jl","title":"Retorno:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"Retorna o vetor C0 com os coeficientes iniciais, de acordo com a opção selecionada.","category":"page"},{"location":"serial-finite-elements/#Exemplo-de-Uso:-5","page":"SerialFiniteElements.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"serial-finite-elements/","page":"SerialFiniteElements.jl","title":"SerialFiniteElements.jl","text":"# Função de condição inicial\nu0(x) = sin(x)\n\n# Chamada da função com opção de interpolação\nC0 = C0_options(1, u0, 0.0, ne, m, h, npg, EQoLG)\nprintln(C0)","category":"page"},{"location":"generate-packages/#Como-criar-seu-pacote-em-*Julia*","page":"Gerar pacotes","title":"Como criar seu pacote em Julia","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Para transformar seu projeto em Julia em um pacote, você deve seguir uma série de etapas que seguem as convenções padrão da linguagem. Isso facilita a instalação, o uso e o compartilhamento do pacote. Aqui está um guia para ajudá-lo:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#1.-**Estrutura-do-Projeto**","page":"Gerar pacotes","title":"1. Estrutura do Projeto","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Certifique-se de que o projeto tenha uma estrutura de diretório compatível com pacotes Julia. O layout típico é:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"MyPackage/\n├── Project.toml\n├── src/\n│   └── MyPackage.jl\n└── test/\n    └── runtests.jl","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"MyPackage: Substitua pelo nome do seu pacote. É uma boa prática usar o estilo CamelCase.\nsrc/MyPackage.jl: Arquivo principal onde você define o módulo do pacote.\ntest/runtests.jl: Opcional, usado para escrever testes automatizados.","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#2.-**Criar-o-Arquivo-Project.toml**","page":"Gerar pacotes","title":"2. Criar o Arquivo Project.toml","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"O arquivo Project.toml contém metadados do pacote, como nome, versão e dependências. Para criá-lo automaticamente:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Inicialize o ambiente do pacote:\nusing Pkg\nPkg.generate(\"MyPackage\")\nIsso criará a estrutura básica do pacote.\nPersonalize o Project.toml: Edite o arquivo para incluir informações relevantes. Exemplo:\nname = \"MyPackage\"\nuuid = \"01234567-89ab-cdef-0123-456789abcdef\"  # Gerado automaticamente\nversion = \"0.1.0\"\n\n[deps]  # Dependências externas\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]  # Compatibilidade com versões do Julia e pacotes\njulia = \"1.6\"","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#3.-**Definir-o-Módulo-Principal**","page":"Gerar pacotes","title":"3. Definir o Módulo Principal","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"No arquivo src/MyPackage.jl, defina o módulo principal:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"module MyPackage\n\nexport say_hello\n\nsay_hello() = println(\"Hello from MyPackage!\")\n\nend","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#4.-**Adicionar-Dependências**","page":"Gerar pacotes","title":"4. Adicionar Dependências","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Se o pacote depende de outros pacotes Julia, adicione-os ao ambiente:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"using Pkg\nPkg.add(\"Example\")","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Isso atualiza automaticamente a seção [deps] no Project.toml.","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#5.-**Adicionar-Testes**","page":"Gerar pacotes","title":"5. Adicionar Testes","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Crie testes no arquivo test/runtests.jl:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"using Test\nusing MyPackage\n\n@testset \"Basic Tests\" begin\n    @test say_hello() == nothing\nend","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Execute os testes com:","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Pkg.test(\"MyPackage\")","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#6.-**Registrar-e-Distribuir-o-Pacote**","page":"Gerar pacotes","title":"6. Registrar e Distribuir o Pacote","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Para uso local, você pode ativar e usar o pacote diretamente:\nPkg.activate(\".\")\nPkg.instantiate()\nPara compartilhar, registre o pacote no Julia General Registry:\nHospede o código em um repositório público (por exemplo, GitHub).\nSiga as instruções do Julia Package Registry Guide.","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#7.-**Documentação-(Opcional)**","page":"Gerar pacotes","title":"7. Documentação (Opcional)","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Considere usar ferramentas como Documenter.jl para criar documentação.","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"","category":"page"},{"location":"generate-packages/#Exemplo-Rápido","page":"Gerar pacotes","title":"Exemplo Rápido","text":"","category":"section"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Crie o pacote:\njulia -e 'using Pkg; Pkg.generate(\"MyPackage\")'\nEdite src/MyPackage.jl para implementar seu código.\nAdicione dependências e testes.\nAtive o ambiente local para desenvolvimento:\nPkg.activate(\".\")\nPkg.instantiate()\nRegistre o pacote para distribuição pública, se necessário.","category":"page"},{"location":"generate-packages/","page":"Gerar pacotes","title":"Gerar pacotes","text":"Após seguir esses passos, seu projeto estará configurado como um pacote Julia! 🎉","category":"page"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"Aqui está a documentação traduzida para o português:","category":"page"},{"location":"vectorized-error-analysis/#Módulo-VectorizedErrorAnalysis","page":"VectorizedErrorAnalysis.jl","title":"Módulo VectorizedErrorAnalysis","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"Este módulo fornece uma abordagem vetorizada para a análise de erros em discretizações de elementos finitos. Ele inclui funções para calcular os erros em aproximações de soluções e para plotar a convergência de erros para diferentes discretizações.","category":"page"},{"location":"vectorized-error-analysis/#Funções","page":"VectorizedErrorAnalysis.jl","title":"Funções","text":"","category":"section"},{"location":"vectorized-error-analysis/#erro_vectorized(u::Function,-X::Matrix{Float64},-u_eval::Matrix{Float64},-ne::Int64,-m::Int64,-h::Float64,-npg::Int64,-C::Vector{Float64},-EQoLG::Matrix{Int64})::Float64","page":"VectorizedErrorAnalysis.jl","title":"erro_vectorized(u::Function, X::Matrix{Float64}, u_eval::Matrix{Float64}, ne::Int64, m::Int64, h::Float64, npg::Int64, C::Vector{Float64}, EQoLG::Matrix{Int64})::Float64","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"Calcula o erro para uma aproximação dada utilizando uma abordagem vetorizada.","category":"page"},{"location":"vectorized-error-analysis/#Argumentos:","page":"VectorizedErrorAnalysis.jl","title":"Argumentos:","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"u::Function: A função representando a solução exata.\nX::Matrix{Float64}: As coordenadas da malha para o domínio do problema.\nu_eval::Matrix{Float64}: A matriz da solução avaliada.\nne::Int64: O número de elementos na discretização.\nm::Int64: O número de nós por elemento.\nh::Float64: O tamanho da malha.\nnpg::Int64: O número de pontos de Gauss por elemento.\nC::Vector{Float64}: O vetor de coeficientes.\nEQoLG::Matrix{Int64}: A matriz de conectividade de elementos.","category":"page"},{"location":"vectorized-error-analysis/#Retorna:","page":"VectorizedErrorAnalysis.jl","title":"Retorna:","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"Float64: O valor do erro calculado.","category":"page"},{"location":"vectorized-error-analysis/#Exemplo-de-Uso:","page":"VectorizedErrorAnalysis.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"# Define uma função representando a solução exata\nu_exata(x) = sin(pi * x)\n\n# Configuração da malha e avaliação\nX = [0.0, 0.5, 1.0]\nu_eval = [0.0, 0.5, 1.0]\nne = 2\nm = 1\nh = 0.5\nnpg = 2\nC = [1.0, 0.5]\nEQoLG = [1 2; 2 3]\n\n# Calcula o erro\nerro = erro_vectorized(u_exata, X, u_eval, ne, m, h, npg, C, EQoLG)\nprintln(\"Erro: $erro\")","category":"page"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"","category":"page"},{"location":"vectorized-error-analysis/#calculate_errors(tam::Int64,-u::Function,-u0::Function,-f::Function,-EQoLG_func::Function,-K_func::Function,-C0_options::Function,-α::Float64,-β::Float64,-γ::Float64,-a::Float64,-b::Float64,-npg::Int64,-option::Int64)","page":"VectorizedErrorAnalysis.jl","title":"calculate_errors(tam::Int64, u::Function, u0::Function, f::Function, EQoLG_func::Function, K_func::Function, C0_options::Function, α::Float64, β::Float64, γ::Float64, a::Float64, b::Float64, npg::Int64, option::Int64)","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"Calcula e plota a convergência do erro para diferentes discretizações.","category":"page"},{"location":"vectorized-error-analysis/#Argumentos:-2","page":"VectorizedErrorAnalysis.jl","title":"Argumentos:","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"tam::Int64: O número máximo de elementos na discretização.\nu::Function: A função representando a solução exata.\nu0::Function: A função das condições iniciais.\nf::Function: A função do termo fonte.\nEQoLG_func::Function: Uma função para gerar a matriz de conectividade de elementos.\nK_func::Function: Uma função para gerar a matriz de rigidez.\nC0_options::Function: Uma função para gerar o vetor de coeficiente inicial.\nα::Float64: Um parâmetro para a matriz de rigidez.\nβ::Float64: Um parâmetro para a matriz de rigidez.\nγ::Float64: Um parâmetro para a matriz de rigidez.\na::Float64: O limite esquerdo do domínio.\nb::Float64: O limite direito do domínio.\nnpg::Int64: O número de pontos de Gauss por elemento.\noption::Int64: Um indicador para selecionar diferentes opções de coeficientes.","category":"page"},{"location":"vectorized-error-analysis/#Retorna:-2","page":"VectorizedErrorAnalysis.jl","title":"Retorna:","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"Vector{Float64}: Um vetor de valores de erro para cada discretização.","category":"page"},{"location":"vectorized-error-analysis/#Exemplo-de-Uso:-2","page":"VectorizedErrorAnalysis.jl","title":"Exemplo de Uso:","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"# Define as funções necessárias\nu_exata(x) = sin(pi * x)\nu0(x) = 0.0\nf(x, t) = 0.0\nEQoLG_func(ne) = [1 2; 2 3]\nK_func(ne, m, h, npg, α, β, γ, EQoLG) = eye(ne)  # Exemplo simples de matriz de rigidez\nC0_options(option, u0, a, ne, m, h, npg, EQoLG) = [1.0, 0.5]\n\n# Configura os parâmetros\ntam = 10\nα = 1.0\nβ = 0.0\nγ = 0.0\na = 0.0\nb = 1.0\nnpg = 2\noption = 1\n\n# Calcula os erros\nerros = calculate_errors(tam, u_exata, u0, f, EQoLG_func, K_func, C0_options, α, β, γ, a, b, npg, option)\nprintln(\"Erros: $erros\")","category":"page"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"","category":"page"},{"location":"vectorized-error-analysis/#Dependências","page":"VectorizedErrorAnalysis.jl","title":"Dependências","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"VectorizedFiniteElements: Usado para operações vetorizadas em elementos finitos.\nMDEDiscretization: Fornece esquemas de discretização.\nLinearAlgebra: Fornece utilitários de álgebra linear.\nPlots: Usado para plotar a convergência do erro.","category":"page"},{"location":"vectorized-error-analysis/#Plotando-a-Convergência-do-Erro","page":"VectorizedErrorAnalysis.jl","title":"Plotando a Convergência do Erro","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"A função calculate_errors retorna os erros para diferentes discretizações, os quais podem ser plotados para visualizar a convergência do erro. O gráfico pode ser personalizado usando o pacote Plots.","category":"page"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"using Plots\n\n# Exemplo de plotagem da convergência do erro\nplot(erros, xlabel=\"Índice de Discretização\", ylabel=\"Erro\", title=\"Convergência do Erro\")","category":"page"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"","category":"page"},{"location":"vectorized-error-analysis/#Notas","page":"VectorizedErrorAnalysis.jl","title":"Notas","text":"","category":"section"},{"location":"vectorized-error-analysis/","page":"VectorizedErrorAnalysis.jl","title":"VectorizedErrorAnalysis.jl","text":"O módulo utiliza operações vetorizadas para otimizar o cálculo dos erros, melhorando o desempenho para tamanhos de problemas grandes.\nA convergência do erro é calculada para diferentes refinamentos da malha, e os resultados podem ser usados para avaliar a ordem de convergência.","category":"page"},{"location":"#1.-Introdução-e-Formulação-do-Problema","page":"FastFE.jl","title":"1. Introdução e Formulação do Problema","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Dados alpha  0, beta gamma geq 0 constantes reais e funções f 0 1 times 0 T rightarrow mathbbR, u_0 0 1 rightarrow mathbbR e g mathbbR to mathbbR, determine u 0 1 times 0 T to mathbbR tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\label{edo} \\begin{cases} ut(x, t) -\\alpha u{xx}(x, t) + \\gamma u{x}(x, t) + \\beta u(x, t) + g(u(x, t)) = f(x, t), & \\forall(x, t) \\in (0, 1) \\times [0, T] \\\nu(0, t) = u(1, t) = 0, & \\forall t \\in [0, T] \\\nu(x, 0) = u0(x), & \\forall x \\in (0, 1) \\end{cases}. \\tag{1} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Sejam considerados os conjuntos:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"H \\triangleq {u \\text{ suficientemente suave}: u(0) = u(1) = 0} \\\nV = H. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"H","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"é denominado espaço das soluções do problema e V é denominado espaço das funções testes. O primeiro passo que iremos fazer é multiplicar ambos os lados da Equação Diferencial Ordinária (\\ref{edo}) por uma função v(x) in V:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"v(x)(ut(x, t) - \\alpha u{xx}(x, t) + \\gamma ux(x, t) + \\beta u(x, t) + g(u(x, t))) = v(x)f(x, t) \\Rightarrow (\\text{Distribui } v(x) ) \\\nv(x)ut(x, t) - \\alpha v(x)u{xx}(x, t) + \\gamma v(x)ux(x, t) + \\beta v(x)u(x, t) + v(x)g(u(x, t)) = v(x)f(x, t). $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Agora integramos ambos os lados no intervalo x in 0 1 e aproveitamos para reduzir a ordem da derivada de u:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\int^10(v(x)ut(x, t) - \\alpha v(x)u{xx}(x, t) + \\gamma v(x)ux(x, t) + \\beta v(x)u(x, t) + v(x)g(u(x, t)))\\,dx = \\int^10v(x)f(x, t)\\,dx \\Rightarrow (\\text{Linearidade da integral}) \\\n\\int^10v(x)ut(x, t)\\,dx - \\alpha\\int^10v(x)u{xx}(x, t)\\,dx + \\gamma\\int^10v(x)ux(x, t)\\,dx + \\beta\\int^10v(x)u(x, t)\\,dx + \\int^10v(x)g(u(x, t))\\,dx = \\int^10v(x)f(x, t)\\,dx \\Rightarrow (\\text{Integração por partes}) \\\n\\int^10v(x)\\frac{\\partial u(x, t)}{\\partial t}\\,dx - \\alpha\\left(v(x)\\frac{\\partial u(x, t)}{\\partial x}\\Bigg|^10 -\\int^10\\frac{dv(x)}{\\,dx}\\frac{\\partial u(x, t)}{\\partial x}\\,dx\\right) + \\gamma\\int^10v(x)\\frac{\\partial u(x, t)}{\\partial x}\\,dx + \\beta\\int^10v(x)u(x, t)\\,dx + \\int^10v(x)g(u(x, t))\\,dx = \\int^10v(x)f(x, t)\\,dx \\Rightarrow (v(1) = v(0) = 0) \\\n\\int^10v(x)\\frac{\\partial u(x, t)}{\\partial t}\\,dx + \\alpha\\int^10\\frac{dv(x)}{\\,dx}\\frac{\\partial u(x, t)}{\\partial x}\\,dx + \\gamma\\int^10v(x)\\frac{\\partial u(x, t)}{\\partial x}\\,dx + \\beta\\int^10v(x)u(x, t)\\,dx + \\int^10v(x)g(u(x, t))\\,dx = \\int^1_0v(x)f(x, t)\\,dx. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Nesse formato, o problema possui apenas derivadas de primeira ordem, relaxando a necessidade da função u ser duas vezes diferenciável em todo o seu domínio. Esse formato é denominado Formulação Fraca e será devidamente definido a seguir.","category":"page"},{"location":"#2.-Formulação-Fraca-do-Problema:","page":"FastFE.jl","title":"2. Formulação Fraca do Problema:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Dados alpha  0, beta gamma geq 0 constantes reais e funções funções f 0 1 times 0 T rightarrow mathbbR e u_0 0 1 rightarrow mathbbR, determine u 0 1 times 0 T to mathbbR tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\label{ffp} \\int^10v(x)\\frac{\\partial u(x, t)}{\\partial t}\\,dx + \\alpha\\int^10\\frac{dv(x)}{\\,dx}\\frac{\\partial u(x, t)}{\\partial x}\\,dx + \\gamma\\int^10v(x)\\frac{\\partial u(x, t)}{\\partial x}\\,dx + \\beta\\int^10v(x)u(x, t)\\,dx + \\int^10v(x)g(u(x, t))\\,dx = \\int^10v(x)f(x, t)\\,dx, \\quad \\forall v \\in V. \\tag{2} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Será utilizada a seguinte notação:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{cases} \\kappa(\\cdot, \\cdot): V \\times V \\to \\mathbb{R} \\\n(v, u) \\mapsto \\alpha\\int^10\\frac{dv(x)}{\\,dx}\\frac{du(x)}{dx}\\,dx + \\gamma\\int^10v(x)\\frac{du(x)}{dx}\\,dx + \\beta\\int^10v(x)u(x)\\,dx \\\n\\end{cases} \\quad \\begin{cases} (\\cdot, \\cdot): V \\times C{[0,\\ 1]} \\\n(v, u) \\mapsto \\int^1_0v(x)u(x)\\,dx. \\end{cases} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Em que C_D triangleq f mathbbD to mathbbR f text é contínua em todo domínio D. Nosso problema é então descrito por:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\label{notacao} (v, u_t(t)) + \\kappa(v, u(t)) + (v, g(u(t))) = (v, f(t)), \\quad \\forall v \\in V. \\tag{3} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Note que no problema definido em (\\ref{notacao}), as funções transientes estão fixadas em um determinado tempo t. O próximo passo é aproximar o espaço V por um espaço V_m triangleq sum^m_j=1C_jvarphi_j(x) C_j in mathbbR j = 1 2 ldots m, em que as funções varphi_i, forall i in 1 2 ldots m, formam uma base para um subespaço finito das funções teste V. Vamos considerar a seguinte função construída como combinação linear das funções da base do subespaço finito:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\tilde{u}(x) = \\sum^m{j=1}Cj\\varphi_j(x). $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Essa será a função que utilizaremos para resolver numericamente o problema no espaço. Agora podemos passar para um problema aproximado que será definido logo abaixo.","category":"page"},{"location":"#3.-Problema-Semi-discreto-Via-Método-de-Galerkin-na-Variável-Espacial:","page":"FastFE.jl","title":"3. Problema Semi-discreto - Via Método de Galerkin na Variável Espacial:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Dados alpha  0, beta gamma geq 0 constantes reais e funções funções f 0 1 times 0 T rightarrow mathbbR e tildeu_0 in V_m uma aproximação para u_0, determine tildeu(t) in V_m t in 0 T tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\label{galerkin} \\begin{cases} (\\tilde{v}, \\tilde{u}t(t)) + \\kappa(\\tilde{v}, \\tilde{u}(t)) + (\\tilde{v}, g(\\tilde{u}(t))) = (\\tilde{v}, f(t)), \\quad \\forall \\tilde{v} \\in Vm \\\n\\tilde{u}(0) = \\tilde{u}_0 \\end{cases}. \\tag{4} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Queremos determinar tildeu(t), isto é, queremos determinar os coeficientes C_i, forall i in 1 2 ldots m tal que tildeu(t) satisfaça (\\ref{galerkin}). Porém, a nossa definição de tildeu(x) não depende do tempo. A estratégia é definir um conjunto de funções tildeu^(n)(x), em que teremos que determinar as componentes do vetor C^(n) para cada tempo t_n. Primeiro, vamos fazer uma aproximação de ordem quadrática para a derivada tildeu_t(t_n-frac12) approx fractildeu(t_n) - tildeu(t_n-1)tau (Método Crank-Nicolson), em que t_n-frac12 = fract_n + t_n-12, e discretizar o domínio do tempo uniformemente a partir de um passo tau in mathbbR^+ de modo que 0 = t_0  t_1  ldots  t_N leq T t_n = ntau forall n in 0 ldots N. Nosso problema totalmente discreto é definido a seguir.","category":"page"},{"location":"#4.-Problema-Totalmente-Discreto-Galerkin-no-Espaço-e-Crank-Nicolson-no-Tempo:","page":"FastFE.jl","title":"4. Problema Totalmente Discreto - Galerkin no Espaço e Crank-Nicolson no Tempo:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Dados alpha  0, beta gamma geq 0 constantes reais e funções funções f 0 1 times 0 T rightarrow mathbbR e tildeu_0 in V_m uma aproximação para u_0, determine U^(n) in V_m tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{cases}\\label{cranknic} \\left(\\tilde{v}, \\frac{U^{(n)} - U^{(n-1)}}{\\tau}\\right) + \\kappa\\left(\\tilde{v}, \\frac{U^{(n)} + U^{(n-1)}}{2}\\right) + (\\tilde{v}, g(U^{(n-\\frac{1}{2})})) = \\left(\\tilde{v}, f(t{n - \\frac{1}{2}})\\right), \\quad \\forall \\tilde{v} \\in Vm \\\nU^{(0)} = \\tilde{u}0 \\end{cases}. \\tag{5} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Para U^(n) = tildeu(t_n), tildeu(t_n - frac12) approx fracU^(n) + U^(n-1)2, 0 = t_0  t_1  ldots  t_N leq T t_n = ntau forall n in 0 ldots N e t_n-frac12 = fract_n + t_n-12. Tendo em vista que tildev in V_m, em particular, tildev pode ser uma das funções da base. Essa escolha irá ser de grande ajuda para determinar os coeficientes de U^(n)(x) = sum^m_j=1C^(n)_jvarphi_j(x), como veremos a seguir:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\left(\\tilde{v}, \\frac{U^{(n)} - U^{(n-1)}}{\\tau}\\right) + \\kappa\\left(\\tilde{v}, \\frac{U^{(n)} + U^{(n-1)}}{2}\\right) + \\left(\\tilde{v}, g(U^{(n-\\frac{1}{2})})\\right) = \\left(\\tilde{v}, f(t{n - \\frac{1}{2}})\\right) \\Rightarrow (\\text{Definição de } U) \\\n\\left(\\tilde{v}, \\frac{\\sum^m{j=1}C^{(n)}j\\varphij - \\sum^m{j=1}C^{(n-1)}j\\varphij}{\\tau}\\right) + \\kappa\\left(\\tilde{v}, \\frac{\\sum^m{j=1}C^{(n)}j\\varphij + \\sum^m{j=1}C^{(n-1)}j\\varphij}{2}\\right) + \\left(\\tilde{v}, g(U^{(n-\\frac{1}{2})})\\right) = \\left(\\tilde{v}, f(t{n - \\frac{1}{2}})\\right) \\Rightarrow (\\text{Escolha de função da base}) \\\n\\left(\\varphii, \\frac{\\sum^m{j=1}C^{(n)}j\\varphij - \\sum^m{j=1}C^{(n-1)}j\\varphij}{\\tau}\\right) + \\kappa\\left(\\varphii, \\frac{\\sum^m{j=1}C^{(n)}j\\varphij + \\sum^m{j=1}C^{(n-1)}j\\varphij}{2}\\right) + \\left(\\varphii, g(U^{(n-\\frac{1}{2})})\\right) = \\left(\\varphii, f(t{n - \\frac{1}{2}})\\right) \\Rightarrow (\\text{Rearranjando o somatório}) \\\n\\left(\\varphii, \\frac{\\sum^m{j=1}(C^{(n)}j - C^{(n-1)}j)\\varphij}{\\tau}\\right) + \\kappa\\left(\\varphii, \\frac{\\sum^m{j=1}(C^{(n)}j + C^{(n-1)}j)\\varphij}{2}\\right) + \\left(\\varphii, g(U^{(n-\\frac{1}{2})})\\right) = \\left(\\varphii, f(t{n - \\frac{1}{2}})\\right) \\Rightarrow (\\text{Operador } \\kappa \\text{ bilinear}) \\\n\\sum^m{j=1}\\left(\\varphii, \\varphij\\right)\\frac{(C^{(n)}j - C^{(n-1)}j)}{\\tau} + \\sum^m{j=1}\\kappa\\left(\\varphii, \\varphij\\right)\\frac{(C^{(n)}j + C^{(n-1)}j)}{2} + \\left(\\varphii, g(U^{(n-\\frac{1}{2})})\\right) = \\left(\\varphii, f(t_{n - \\frac{1}{2}})\\right), \\quad \\forall i \\in {1,\\ 2,\\ \\ldots,\\ m}. $","category":"page"},{"location":"#5.-Lidando-com-a-Função-Não-linear-g(s)-(Linearizando-com-Ordem-Quadrática):","page":"FastFE.jl","title":"5. Lidando com a Função Não-linear g(s) (Linearizando com Ordem Quadrática):","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Vamos utilizar a aproximação U^(n-frac12) approx frac3U^(n-1) - U^(n-2)2 para obter a seguinte equação:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\sum^m{j=1}\\left(\\varphii, \\varphij\\right)\\frac{(C^{(n)}j - C^{(n-1)}j)}{\\tau} + \\sum^m{j=1}\\kappa\\left(\\varphii, \\varphij\\right)\\frac{(C^{(n)}j + C^{(n-1)}j)}{2} + \\left(\\varphii, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) = \\left(\\varphii, f(t{n - \\frac{1}{2}})\\right) \\Rightarrow \\\n\\sum^m{j=1}\\left(\\varphii, \\varphij\\right)\\frac{(C^{(n)}j - C^{(n-1)}j)}{\\tau} + \\sum^m{j=1}\\kappa\\left(\\varphii, \\varphij\\right)\\frac{(C^{(n)}j + C^{(n-1)}j)}{2} = \\left(\\varphii, f(t{n - \\frac{1}{2}})\\right) - \\left(\\varphii, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right), \\quad \\forall i \\in {1,\\ 2,\\ \\ldots,\\ m}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Podemos montar um sistema linear mtimes m para um vetor C^(n)_1times m de incógnitas descrito a seguir.","category":"page"},{"location":"#6.-Formulação-Matricial:","page":"FastFE.jl","title":"6. Formulação Matricial:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Vamos considerar a última equação acima para i = 1 2 ldots m:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{cases} \\sum^m{j=1}\\left(\\varphi1, \\varphij\\right)\\frac{(C^{(n)}j - C^{(n-1)}j)}{\\tau} + \\sum^m{j=1}\\kappa\\left(\\varphi1, \\varphij\\right)\\frac{(C^{(n)}j + C^{(n-1)}j)}{2} = \\left(\\varphi1, f(t{n - \\frac{1}{2}})\\right) - \\left(\\varphi1, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) \\\n\\sum^m{j=1}\\left(\\varphi2, \\varphij\\right)\\frac{(C^{(n)}j - C^{(n-1)}j)}{\\tau} + \\sum^m{j=1}\\kappa\\left(\\varphi2, \\varphij\\right)\\frac{(C^{(n)}j + C^{(n-1)}j)}{2} = \\left(\\varphi2, f(t{n - \\frac{1}{2}})\\right) - \\left(\\varphi2, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) \\\n\\vdots \\\n\\sum^m{j=1}\\left(\\varphim, \\varphij\\right)\\frac{(C^{(n)}j - C^{(n-1)}j)}{\\tau} + \\sum^m{j=1}\\kappa\\left(\\varphim, \\varphij\\right)\\frac{(C^{(n)}j + C^{(n-1)}j)}{2} = \\left(\\varphim, f(t{n - \\frac{1}{2}})\\right) - \\left(\\varphi_m, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) \\end{cases}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Sendo assim, matricialmente, temos que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\frac{1}{\\tau} \\begin{bmatrix} (\\varphi1, \\varphi1) & (\\varphi1, \\varphi2) & \\cdots & (\\varphi1, \\varphim) \\\n(\\varphi2, \\varphi1) & (\\varphi2, \\varphi2) & \\cdots & (\\varphi2, \\varphim) \\\n\\vdots & \\cdots & \\ddots & \\vdots \\\n(\\varphim, \\varphi1) & (\\varphim, \\varphi2) & \\cdots & (\\varphim, \\varphim) \\end{bmatrix} \\begin{bmatrix} C^{(n)}1 - C^{(n-1)}1 \\\nC^{(n)}2 - C^{(n-1)}2 \\\n\\vdots \\\nC^{(n)}m - C^{(n-1)}m \\end{bmatrix}","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\frac{1}{2} \\begin{bmatrix} \\kappa(\\varphi1, \\varphi1) & \\kappa(\\varphi1, \\varphi2) & \\cdots & \\kappa(\\varphi1, \\varphim) \\\n\\kappa(\\varphi2, \\varphi1) & \\kappa(\\varphi2, \\varphi2) & \\cdots & \\kappa(\\varphi2, \\varphim) \\\n\\vdots & \\cdots & \\ddots & \\vdots \\\n\\kappa(\\varphim, \\varphi1) & \\kappa(\\varphim, \\varphi2) & \\cdots & \\kappa(\\varphim, \\varphim) \\end{bmatrix} \\begin{bmatrix} C^{(n)}1 + C^{(n-1)}1 \\\nC^{(n)}2 + C^{(n-1)}2 \\\n\\vdots \\\nC^{(n)}m + C^{(n-1)}m \\end{bmatrix} = \\\n\\begin{bmatrix} (\\varphi1, f(t{n - \\frac{1}{2}})) \\\n(\\varphi2, f(t{n - \\frac{1}{2}})) \\\n\\vdots \\\n(\\varphim, f(t{n - \\frac{1}{2}})) \\end{bmatrix}","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{bmatrix} \\left(\\varphi1, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) \\\n\\left(\\varphi2, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) \\\n\\vdots \\\n\\left(\\varphi_m, g(\\frac{3U^{(n-1)} - U^{(n-2)}}{2})\\right) \\end{bmatrix} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Reescrevendo a equação acima, temos o seguinte sistema linear:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\label{matriz_vetor} \\frac{1}{\\tau}M(C^{(n)} - C^{(n-1)}) + \\frac{1}{2}K(C^{(n)} + C^{(n-1)}) = F(n - \\frac{1}{2}) - G(\\frac{3U^{(n-1)} - U^{(n-1)}}{2}). \\tag{6} $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Para M_ij = (varphi_i varphi_j), K_ij = kappa(varphi_i varphi_j), F_i(n - frac12) = (varphi_i f(t_n - frac12)) e G_i(frac3U^(n-1) - U^(n-1)2) = left(varphi_i g(frac3U^(n-1) - U^(n-2)2)right).","category":"page"},{"location":"#7.-Implementação:","page":"FastFE.jl","title":"7. Implementação:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Estamos utilizando uma função linear para varphi_i(x) definida por:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\varphii(x) = \\begin{cases} \\frac{x - x{i-1}}{x{i} - x{i-1}}, x{i-1} \\leq x \\leq x{i}  \\\n\\frac{x{i+1} - x}{x{i+1} - x{i}}, x{i} \\leq x \\leq x{i+1}  \\\n0, \\text{ caso contrário} \\end{cases} \\quad \\text{e} \\quad \\frac{d\\varphii(x)}{dx} = \\begin{cases} \\frac{1}{x{i} - x{i-1}}, x{i-1} \\leq x \\leq x{i} \\\n\\frac{-1}{x{i+1} - x{i}}, x{i} \\leq x \\leq x{i+1} \\\n0, \\text{caso contrário} \\end{cases}, \\text{ para } i = 1,\\ 2,\\ \\ldots,\\ m. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Em que x_i = a + i(x_i - x_i-1) = a + ih_i e h_i = x_i - x_i-1, para i = 1 2 ldots m. Como as partições são uniformes, h_i = h é constante. Uma consideração importante é que estaremos utilizando uma extensão dos vetores e das matrizes para m+1 ao invés de m para manter a escrita das equações mais limpa e facilitar o uso das estruturas locais e globais. As matrizes M e K, e os vetores de termos independentes F(n-frac12) e G(U) são calculados a partir da aproximação das respectivas integrais por quadratura gaussiana (notação local):","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\bullet K^e{ab} = \\alpha\\int^{x^e2}{x^e1}\\frac{d\\varphi^ea(x)}{\\,dx}\\frac{d\\varphi^eb(x)}{dx}\\,dx + \\gamma\\int^{x^e2}{x^e1}\\varphi^ea(x)\\frac{d\\varphi^eb(x)}{dx}\\,dx + \\beta\\int^{x^e2}{x^e1}\\varphi^ea(x)\\varphi^eb(x)\\,dx = \\\n\\frac{2\\alpha}{h}\\int^{1}{-1}\\frac{d\\phia(\\xi)}{d\\xi}\\frac{d\\phib(\\xi)}{d\\xi}\\,d\\xi + \\gamma\\int^{1}{-1}\\phia(\\xi)\\frac{d\\phib(\\xi)}{d\\xi}\\,d\\xi + \\frac{\\beta h}{2}\\int^{1}{-1}\\phia(\\xi)\\varphib(\\xi)\\,d\\xi \\approx \\\n\\frac{2\\alpha}{h}\\sum^{N{PG}}{j=1}Wj\\frac{d\\phia(Xj)}{d\\xi}\\frac{d\\phib(Xj)}{d\\xi} + \\gamma\\sum^{N{PG}}{j=1}Wj\\phia(Xj)\\frac{d\\phib(Xj)}{d\\xi} + \\frac{\\beta h}{2}\\sum^{N{PG}}{j=1}Wj\\phia(Xj)\\varphib(Xj), \\quad \\text{para } e \\in {1,\\ 2,\\ \\ldots,\\ m+1}, a, b \\in {1, 2}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\bullet M^e{ab} = \\int^{x^e2}{x^e1}\\varphi^ea(x)\\varphi^eb(x)\\,dx = \\frac{h}{2}\\int^{1}{-1}\\phia(\\xi)\\varphib(\\xi)\\,d\\xi \\approx \\frac{h}{2}\\sum^{N{PG}}{j=1}Wj\\phia(Xj)\\varphib(Xj), \\quad \\text{para } e \\in {1,\\ 2,\\ \\ldots,\\ m+1}, a, b \\in {1, 2}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Em que phi_1(xi) = frac1 - xi2 e phi_2(xi) = frac1 + xi2, X_j e W_j, para j = 1 2 ldots N_PG são os pontos e pesos de Gauss, respectivamente, N_Pg é o número de pontos de Gauss, e x^e_1 = x_e-1 e x^e_2 = x_e (pontos começando de 0 até m+1, com m pontos internos).","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\bullet F^e{a}(n - \\frac{1}{2}) = \\int^{x^e2}{x^e1}\\varphi^ea(x)f(x, t{n - \\frac{1}{2}})\\,dx = \\frac{h}{2}\\int^1{-1}\\phia(\\xi)f(\\frac{h}{2}(1 + \\xi) + x{e-1}, t{n - \\frac{1}{2}})d\\xi \\approx \\\n\\frac{h}{2}\\sum^{N{PG}}{j=1}Wj\\phia(Xj)f(\\frac{h}{2}(Xj+1) + x{e-1}, t{n - \\frac{1}{2}}), \\quad \\text{para } e \\in {1,\\ 2,\\ \\ldots,\\ m+1}, a \\in {1, 2}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\bullet G^ea(U) = \\int^{x^e2}{x^e1}\\varphia(x)g(\\sum^m{j=1}Cj\\varphij(x))\\,dx = \\int^{x^e2}{x^e1}\\varphia(x)g(C{e-1}\\varphi{e-1}(x) + C{e}\\varphie(x))\\,dx = \\int^{1}{-1}\\phia(\\xi)g(C{EQ[LG[1, e]]}\\phi1(\\xi) + C{EQ[LG[2, e]]}\\phi2(\\xi))\\frac{h}{2}\\,d\\xi \\approx \\\n\\frac{h}{2}\\sum^{N{PG}}{j=1}Wj\\phia(Xj)g(C{EQ[LG[1, e]]}\\phi1(Xj) + C{EQ[LG[2, e]]}\\phi2(X_j)), \\quad \\text{para } e \\in {1,\\ 2,\\ \\ldots,\\ m+1}, a \\in {1, 2}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Vamos considerar as seguintes estruturas para mapear os elementos locais para os elementos globais:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"LG = \\begin{bmatrix} 1 & 2 & \\cdots & m+1 \\\n2 & 3 & \\cdots & m + 2 \\end{bmatrix}{2\\times(m+1)} \\quad \\text{ e } \\quad EQ = \\begin{bmatrix} m+1 & 1 & 2 & \\cdots & m & m+1 \\end{bmatrix}{1\\times(m+2)}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Portanto: \\begin{align} M{EQ[LG[a, e]], EQ[LG[b, e]]} &\\gets M^e{ab} \\\nK{EQ[LG[a, e]], EQ[LG[b, e]]} &\\gets K^e{ab} \\\nF{EQ[LG[a, e]]} &\\gets F^e_a \\\nG{EQ[LG[a, e]]} &\\gets G^e_a \\end{align}","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"O erro entre a solução aproximada e a solução exata é dado por:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"||u(x) - \\tilde{u}(x)||^2{L^2} = \\int^10|u(x) - \\tilde{u}(x)|^2dx = \\sum^{m+1}{i=1}\\int^{xi}{x{i-1}}\\left(u(x) - \\sum^m{j=1}Cj\\varphij(x)\\right)^2dx = \\\n\\int^{x1}{x0}(u(x) - C1\\varphi1(x))^2dx + \\sum^{m}{i=2}\\int^{xi}{x{i-1}}\\left(u(x) - C{i-1}\\varphi{i-1}(x) - C{i}\\varphi{i}(x)\\right)^2dx + \\int^{x{m+1}}{xm}(u(x) - Cm\\varphi1(m))^2dx = \\\n\\frac{h}{2}\\left[\\int^{1}{-1}(u(\\frac{h}{2}(\\xi + 1) + x0) - C1\\frac{1 + \\xi}{2})^2d\\xi + \\sum^{m}{i=2}\\int^{1}{-1}\\left(u(\\frac{h}{2}(\\xi + 1) + x{i-1}) - C{i-1}\\frac{1 - \\xi}{2} - C{i}\\frac{1 + \\xi}{2}\\right)^2d\\xi + \\int^{1}{-1}(u(\\frac{h}{2}(\\xi + 1) + xm) - Cm\\frac{1 - \\xi}{2})^2d\\xi\\right] \\approx \\\n\\frac{h}{2}\\left[\\sum^{N{PG}}{j=1}Wj\\left(u(\\frac{h}{2}(Xj + 1) + x{0}) - C1\\frac{1 + Xj}{2}\\right)^2 + \\sum^m{i=2}\\sum^{N{PG}}{j=1}Wj\\left(u(\\frac{h}{2}(Xj + 1) + x{i-1}) - C{i-1}\\frac{1 - Xj}{2} - C{i}\\frac{1 + Xj}{2}\\right)^2 + \\sum^{N{PG}}{j=1}Wj\\left(u(\\frac{h}{2}(Xj + 1) + x{m}) - Cm\\frac{1 - Xj}{2}\\right)^2\\right]. $","category":"page"},{"location":"#8.-Aproximação-de-u_0-Escolhas-de-U{(0)}-\\in-V_m:","page":"FastFE.jl","title":"8. Aproximação de u_0 - Escolhas de U^(0) in V_m:","text":"","category":"section"},{"location":"#8.1-U0-como-interpolante-de-u_0:","page":"FastFE.jl","title":"8.1 U^0 como interpolante de u_0:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"A primeira escolha é dada pela interpolante de u_0. Temos que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"U^0(xi) = \\sum^m{j=1}C^0j\\varphij(xi) = C^0i. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Sendo assim:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"C^0 = \\begin{bmatrix} u0(x1) \\\nu0(x2) \\\n\\vdots \\\nu0(xm) \\end{bmatrix}. $","category":"page"},{"location":"#8.2-U0-como-projeção-L2-de-u_0:","page":"FastFE.jl","title":"8.2 U^0 como projeção L^2 de u_0:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Seja U^0 in V_m tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"(U^0 - u0, vh) = 0 \\Rightarrow (U^0, vh) - (u0, vh) = 0, \\quad \\forall vh \\in V_m. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Tomando U^0(x) = sum^m_j=1C^0_jvarphi_j(x) e v_h = varphi_i, para i = 1 2 ldots m, na equação acima, temos que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"MC^0 = \\begin{bmatrix} (u0, \\varphi1) \\\n(u0, \\varphi2) \\\n\\vdots \\\n(u0, \\varphim) \\end{bmatrix}. $","category":"page"},{"location":"#8.3-U0-como-projeção-H1_0-de-u_0:","page":"FastFE.jl","title":"8.3 U^0 como projeção H^1_0 de u_0:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Seja U^0 in V_m tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\left(\\frac{d}{dx}\\left(U^0 - u0\\right), \\frac{dvh}{dx}\\right) = 0 \\Rightarrow \\left(\\frac{dU^0}{dx}, \\frac{dvh}{dx}\\right) - \\left(\\frac{du0}{dx}, \\frac{dvh}{dx}\\right) = 0, \\quad \\forall vh \\in V_m. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Tomando U^0(x) = sum^m_j=1C^0_jvarphi_j(x) e v_h = varphi_i, para i = 1 2 ldots m, na equação acima, temos que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{bmatrix} (\\frac{d\\varphi1}{dx}, \\frac{d\\varphi1}{dx}) & (\\frac{d\\varphi1}{dx}, \\frac{d\\varphi2}{dx}) & \\cdots & (\\frac{d\\varphi1}{dx}, \\frac{d\\varphim}{dx}) \\\n(\\frac{d\\varphi2}{dx}, \\frac{d\\varphi1}{dx}) & (\\frac{d\\varphi2}{dx}, \\frac{d\\varphi2}{dx}) & \\cdots & (\\frac{d\\varphi2}{dx}, \\frac{d\\varphim}{dx}) \\\n\\vdots & \\vdots & \\ddots & \\vdots \\\n(\\frac{d\\varphim}{dx}, \\frac{d\\varphi1}{dx}) & (\\frac{d\\varphim}{dx}, \\frac{d\\varphi2}{dx}) & \\cdots & (\\frac{d\\varphim}{dx}, \\frac{d\\varphim}{dx}) \\end{bmatrix}C^0 = \\begin{bmatrix} (\\frac{du0}{dx}, \\frac{d\\varphi1}{dx}) \\\n(\\frac{du0}{dx}, \\frac{d\\varphi2}{dx}) \\\n\\vdots \\\n(\\frac{du0}{dx}, \\frac{d\\varphim}{dx}) \\end{bmatrix}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"O lado direito pode ser obtido a partir das seguintes equações:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{cases} (\\frac{du0}{dx}, \\frac{d\\varphi^{(e)}1}{dx}) = \\int^10\\frac{du0}{dx}\\frac{d\\varphi1}{dx}\\,dx = -\\frac{1}{h}\\int^10\\frac{du0}{dx}\\,dx = (u0(a + (e-1)h) - u0(a + eh))/h \\\n(\\frac{du0}{dx}, \\frac{d\\varphi^{(e)}1}{dx}) = \\int^10\\frac{du0}{dx}\\frac{d\\varphi1}{dx}\\,dx = \\frac{1}{h}\\int^10\\frac{du0}{dx}\\,dx = (u0(a + (e-1)h) - u0(a + eh))/h \\end{cases}, \\quad \\text{para } e \\in {1,\\ 2,\\ \\ldots,\\ m+1}, a \\in {1, 2}. \\\nV{EQ[LG[a, e]]} \\gets V^{(e)}a,\\quad \\text{em que } V \\text{ representa o vetor do lado direito}. $","category":"page"},{"location":"#8.4-Utilizando-o-operador-\\kappa(\\cdot,-\\cdot)-para-realizar-a-projeção-de-u_0:","page":"FastFE.jl","title":"8.4 Utilizando o operador kappa(cdot cdot) para realizar a projeção de u_0:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Seja U^0 in V_m tal que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\kappa\\left(\\left(U^0 - u0\\right), vh\\right) = 0 \\Rightarrow \\kappa\\left(U^0, vh\\right) - \\kappa\\left(u0, vh\\right) = 0, \\quad \\forall vh \\in V_m. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Tomando U^0(x) = sum^m_j=1C^0_jvarphi_j(x) e v_h = varphi_i, para i = 1 2 ldots m, na equação acima, temos que:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"KC^0 = \\begin{bmatrix} \\kappa(u0, \\varphi1) \\\n\\kappa(u0, \\varphi2) \\\n\\vdots \\\n\\kappa(u0, \\varphim) \\end{bmatrix}. $","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"O lado direito pode ser obtido a partir das seguintes equações:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\begin{cases} \\kappa(u0, \\varphi^{(e)}1) = \\alpha\\int^10\\frac{du0(x)}{\\,dx}\\frac{d\\varphi^{(e)}1(x)}{dx}\\,dx + \\gamma\\int^10u0(x)\\frac{d\\varphi^{(e)}1(x)}{dx}\\,dx + \\beta\\int^10u0(x)\\varphi^{(e)}1(x)\\,dx = \\frac{\\alpha}{h}(u0(a+(e-1)h)-u0(a+eh)) + \\frac{\\gamma h}{2}\\sum^{N{pg}}{j=1}Wj\\left(\\frac{du0}{\\,dx}\\left(\\frac{h}{2}(Xj + 1) + (e-1)h\\right)\\phi1(Xj)\\right) + \\frac{\\beta h}{2}\\sum^{N{pg}}{j=1}Wj\\left(u0\\left(\\frac{h}{2}(Xj + 1) + (e-1)h\\right)\\frac{1 - Xj}{2}\\right) \\\n\\kappa(u0, \\varphi^{(e)}2) = \\alpha\\int^10\\frac{du0(x)}{\\,dx}\\frac{d\\varphi^{(e)}2(x)}{dx}\\,dx + \\gamma\\int^10u0(x)\\frac{d\\varphi^{(e)}2(x)}{dx}\\,dx + \\beta\\int^10u0(x)\\varphi^{(e)}2(x)\\,dx = \\frac{\\alpha}{h}(u0(a+eh) - u0(a+(e-1)h)) + \\frac{\\gamma h}{2}\\sum^{N{pg}}{j=1}Wj\\left(\\frac{du0}{\\,dx}\\left(\\frac{h}{2}(Xj + 1) + (e-1)h\\right)\\phi2(Xj)\\right) + \\frac{\\beta h}{2}\\sum^{N{pg}}{j=1}Wj\\left(u0\\left(\\frac{h}{2}(Xj + 1) + (e-1)h\\right)\\frac{1 + Xj}{2}\\right) \\end{cases}, \\quad \\text{para } e \\in {1,\\ 2,\\ \\ldots,\\ m+1}, a \\in {1, 2}. \\\nV{EQ[LG[a, e]]} \\gets V^{(e)}a,\\quad \\text{em que } V \\text{ representa o vetor do lado direito}. $","category":"page"},{"location":"#9.-Determinando-U{(1)}-Método-Preditor-Corretor:","page":"FastFE.jl","title":"9. Determinando U^(1) - Método Preditor-Corretor:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Precisamos determinar U^(1) para poder utilizar a relação de recorrência da forma matricial do problema. Para isso, vamos utilizar um método preditor-corretor que em um passo nos dá uma aproximação no tempo t_1 a partir das duas seguintes etapas:","category":"page"},{"location":"#(i)-Etapa-1:","page":"FastFE.jl","title":"(i) Etapa 1:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Definimos tildeU^(1) in V_m como solução do seguinte problema:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\left(\\tilde{v}, \\frac{\\tilde{U}^{(1)} - U^{(0)}}{\\tau}\\right) + \\kappa\\left(\\tilde{v}, \\frac{\\tilde{U}^{(1)} + U^{(0)}}{2}\\right) = \\left(\\tilde{v}, f(t{n - \\frac{1}{2}})\\right) - (\\tilde{v}, g(U^{(0)})), \\quad \\forall \\tilde{v} \\in Vm. $","category":"page"},{"location":"#(ii)-Etapa-2:","page":"FastFE.jl","title":"(ii) Etapa 2:","text":"","category":"section"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"Determinamos uma aproximação para U^(1) in V_m que é a solução do seguinte problema:","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"$","category":"page"},{"location":"","page":"FastFE.jl","title":"FastFE.jl","text":"\\left(\\tilde{v}, \\frac{U^{(1)} - U^{(0)}}{\\tau}\\right) + \\kappa\\left(\\tilde{v}, \\frac{U^{(1)} + U^{(0)}}{2}\\right) = \\left(\\tilde{v}, f(t{n - \\frac{1}{2}})\\right) - (\\tilde{v}, g(\\frac{\\tilde{U}^{(1)} + U^{(0)}}{2})), \\quad \\forall \\tilde{v} \\in Vm. $","category":"page"},{"location":"serial-error-analysis/#Módulo-SerialErrorAnalysis","page":"SerialErrorAnalysis.jl","title":"Módulo SerialErrorAnalysis","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"Este módulo fornece uma abordagem serial para o cálculo da análise de erro em discretizações de elementos finitos. Ele inclui funções para calcular os erros nas aproximações das soluções e para plotar a convergência do erro para diferentes discretizações.","category":"page"},{"location":"serial-error-analysis/#Funções","page":"SerialErrorAnalysis.jl","title":"Funções","text":"","category":"section"},{"location":"serial-error-analysis/#calculate*errors*serial(tam::Int64,-u::Function,-u0::Function,-f::Function,-EQoLG_func::Function,","page":"SerialErrorAnalysis.jl","title":"`calculateerrorsserial(tam::Int64, u::Function, u0::Function, f::Function, EQoLG_func::Function,","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"                         K_func::Function, C0_options::Function, α::Float64, β::Float64, γ::Float64, \n                         a::Float64, b::Float64, npg::Int64, option::Int64)`","category":"page"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"Calcula e plota a convergência do erro para diferentes discretizações utilizando uma abordagem serial.","category":"page"},{"location":"serial-error-analysis/#Argumentos:","page":"SerialErrorAnalysis.jl","title":"Argumentos:","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"tam::Int64: O número máximo de elementos na discretização.\nu::Function: A função que representa a solução exata.\nu0::Function: A função que representa a condição inicial.\nf::Function: A função do termo fonte.\nEQoLG_func::Function: Uma função para gerar a matriz de conectividade dos elementos.\nK_func::Function: Uma função para gerar a matriz de rigidez.\nC0_options::Function: Uma função para gerar o vetor inicial de coeficientes.\nα::Float64: Um parâmetro para a matriz de rigidez.\nβ::Float64: Um parâmetro para a matriz de rigidez.\nγ::Float64: Um parâmetro para a matriz de rigidez.\na::Float64: A fronteira esquerda do domínio.\nb::Float64: A fronteira direita do domínio.\nnpg::Int64: O número de pontos de Gauss por elemento.\noption::Int64: Uma flag para selecionar diferentes opções de coeficientes.","category":"page"},{"location":"serial-error-analysis/#Retorna:","page":"SerialErrorAnalysis.jl","title":"Retorna:","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"Vector{Float64}: Um vetor com os valores de erro para cada discretização.","category":"page"},{"location":"serial-error-analysis/#Exemplo-de-uso:","page":"SerialErrorAnalysis.jl","title":"Exemplo de uso:","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"# Defina as funções necessárias\nu_exact(x) = sin(pi * x)\nu0(x) = 0.0\nf(x, t) = 0.0\nEQoLG_func(ne) = [1 2; 2 3]\nK_func(ne, m, h, npg, α, β, γ, EQoLG) = eye(ne)  # Exemplo simples de matriz de rigidez\nC0_options(option, u0, a, ne, m, h, npg, EQoLG) = [1.0, 0.5]\n\n# Defina os parâmetros\ntam = 10\nα = 1.0\nβ = 0.0\nγ = 0.0\na = 0.0\nb = 1.0\nnpg = 2\noption = 1\n\n# Calcule os erros\nerros = calculate_errors_serial(tam, u_exact, u0, f, EQoLG_func, K_func, C0_options, α, β, γ, a, b, npg, option)\nprintln(\"Erros: $erros\")","category":"page"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"","category":"page"},{"location":"serial-error-analysis/#Dependências","page":"SerialErrorAnalysis.jl","title":"Dependências","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"SerialFiniteElements: Utilizado para operações de elementos finitos serializados.\nMDEDiscretization: Fornece esquemas de discretização.\nLinearAlgebra: Oferece utilitários de álgebra linear.\nPlots: Usado para plotar a convergência do erro.","category":"page"},{"location":"serial-error-analysis/#Plotando-a-Convergência-do-Erro","page":"SerialErrorAnalysis.jl","title":"Plotando a Convergência do Erro","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"A função calculate_errors_serial retorna os erros para diferentes discretizações, que podem ser plotados para visualizar a convergência do erro. O gráfico pode ser personalizado utilizando o pacote Plots.","category":"page"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"using Plots\n\n# Exemplo de plotagem da convergência do erro\nplot(erros, label=\"Erro\", xlabel=\"Número de Discretizações\", ylabel=\"Erro\", title=\"Convergência do Erro\")","category":"page"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"","category":"page"},{"location":"serial-error-analysis/#Notas","page":"SerialErrorAnalysis.jl","title":"Notas","text":"","category":"section"},{"location":"serial-error-analysis/","page":"SerialErrorAnalysis.jl","title":"SerialErrorAnalysis.jl","text":"O módulo utiliza operações serializadas para calcular os erros, otimizando o desempenho para problemas menores ou onde a paralelização não é necessária.\nA convergência do erro é calculada para diferentes refinamentos da malha, e os resultados podem ser usados para avaliar a ordem de convergência.","category":"page"}]
}
